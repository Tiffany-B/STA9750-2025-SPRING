[
  {
    "objectID": "mp03.html",
    "href": "mp03.html",
    "title": "Mini Project 3",
    "section": "",
    "text": "Echoes of the Boulevard is a collection of 12 songs that expresses the emotional journey of a person going thorugh the motions of life as waves of ups and down. It bridges the nostalgic notes of Coldplay with the rebellious attitudes of Green Day. It’s your go to playlist for when you are staring out the window thinking about life, or for late night walks on a boulevard. In this playlist, you will find ballads of longing, sing-along anthems, powerful chords and melodic piano notes… Most importantly, you will find that you identify with the songs on a personal level.\n\n\n\n\n\n\n\n\nUsing a statistics-based approach, we explored trends in popularity, danceability, energy, valence, track length, and more. By leveraging summary statistics, correlations, and visualizations, we identified key patterns that guided the creation of our desired playlist. The result is a carefully curated selection of tracks that authentically capture the vibe we aimed to achieve.\n\n\n\n\n\n\nBy employing a heuristic-based approach, the selection of songs for the playlist became more precise and intentional. The heuristics used include several key factors: songs that frequently co-occur in playlists alongside anchor tracks, tracks with similar key and tempo, selections from the same artists, songs with acousticness and danceability values within a defined range, and finally, tracks with a comparable valence (emotional tone). By integrating multiple heuristics, this approach effectively curates a playlist where musical and emotional cohesion is maintained, creating a multi-faceted filtering system that enhances meaningful discovery.\n\n\n\n\n\n\nBy prioritizing sonic cohesion, the playlist achieves a well-curated feel. Tracks are ordered based on valence (mood) and energy, ensuring a consistent emotional and rhythmic experience throughout. This approach maintains uniformity in both mood and tempo, enhancing the overall listening journey. Additionally, the visualization of the playlist serves as a validation of its progression, effectively illustrating the evolution of energy, danceability, and emotional tone.\n\n\n\n\n\n\n\nFor this project, we will examine the key factors that influence a song’s popularity in playlists. Our analysis will utilize the Spotify Million Playlist Dataset, a comprehensive collection of playlists and their associated tracks. Additionally, we will integrate a dataset containing Spotify songs and their audio features to enhance our insights. The table below presents the results of the data import and cleaning process, laying the groundwork for a thorough exploration of song popularity dynamics.\n\n\n\n\nCode\nensure_package &lt;- function(pkg) {\n  if (!requireNamespace(pkg, quietly = TRUE)) {\n    install.packages(pkg)\n  }\n  library(pkg, character.only = TRUE)\n}\n\n# Ensure the necessary packages are installed and loaded\nensure_package(\"dplyr\")\nensure_package(\"stringr\")\nensure_package(\"tidyr\")\nensure_package(\"httr2\")\nensure_package(\"rvest\")\nensure_package(\"datasets\")\nensure_package(\"purrr\")\nensure_package(\"DT\")\nensure_package(\"jsonlite\")\nensure_package(\"httr\")\nensure_package(\"knitr\")\n\n#Here we will load the song data from a CSV file (posted by Github User gabminamendez) \nload_songs &lt;- function() {\n  # Define file and directory paths\n  directory &lt;- \"data/mp03\"\n  file_url &lt;- \"https://raw.githubusercontent.com/gabminamedez/spotify-data/refs/heads/master/data.csv\"\n  file_path &lt;- file.path(directory, \"data.csv\")\n  \n  # Create the directory if it doesn't exist\n  if (!dir.exists(directory)) {\n    dir.create(directory, recursive = TRUE)\n  }\n  \n  # Download the file if it doesn't already exist\n  if (!file.exists(file_path)) {\n    download.file(file_url, file_path)\n    message(\"File downloaded: \", file_path)\n  } else {\n    message(\"File already exists: \", file_path)\n  }\n  \n  # Read the CSV file into a data frame\n  song_data &lt;- read.csv(file_path, stringsAsFactors = FALSE)\n  \n  # Process the artists column\n  clean_artist_string &lt;- function(x){\n    str_replace_all(x, \"\\\\['\", \"\") |&gt; \n      str_replace_all(\"'\\\\]\", \"\") |&gt;\n      str_replace_all(\" '\", \"\")\n  }\n  \n  # Process and return the data\n  processed_data &lt;- song_data |&gt; \n    separate_longer_delim(artists, \",\") |&gt;\n    mutate(artist = clean_artist_string(artists)) |&gt;\n    select(-artists)\n  \n  return(processed_data)\n}\n\n# Now actually call the function and save the result\nsong_data &lt;- load_songs()\n\n# View the first few rows to confirm it worked\n# head(song_data)\n# names(song_data)\n# \n# Next, we will load the playlist data from a JSON file (posted by Github User DevinOgrady)\n# Define the function to load the playlist data from the repository, store them locally, and return a tidy data frame to read them into R in a standardized format.\n\nload_playlist &lt;- function() {\n  p_directory &lt;- \"data/mp03/playlists\"\n  p_url &lt;- \"https://raw.githubusercontent.com/DevinOgrady/spotify_million_playlist_dataset/master/data1/\"\n  j_file_name &lt;- \"mpd.slice.0-999.json\"\n  file_path_1 &lt;- file.path(p_directory, j_file_name)\n  file_url_1 &lt;- paste0(p_url, j_file_name)\n  \n  if (!dir.exists(p_directory)) {\n    dir.create(p_directory, recursive = TRUE)\n  }\n  \n  if (!file.exists(file_path_1)) {\n    download.file(file_url_1, destfile = file_path_1, method = \"auto\")\n  }\n  \n  playlist_data &lt;- fromJSON(file_path_1, simplifyVector = FALSE)  \n  \n  if (!\"playlists\" %in% names(playlist_data)) return(NULL)\n  \n  playlist_tracks &lt;- map_dfr(playlist_data$playlists, function(pl) {\n    if (!is.list(pl)) return(NULL)\n    if (!(\"tracks\" %in% names(pl))) return(NULL)\n    if (!is.list(pl$tracks) || length(pl$tracks) == 0) return(NULL)\n    \n    tidy_data &lt;- tryCatch(\n      bind_rows(pl$tracks),\n      error = function(e) NULL\n    )\n    \n    if (is.null(tidy_data) || nrow(tidy_data) == 0) return(NULL)\n    \n    tidy_data |&gt;\n      mutate(\n        playlist_name      = pl$name,\n        playlist_id        = pl$pid,\n        playlist_followers = pl$num_followers,\n        playlist_position  = row_number()\n      ) |&gt;\n      select(\n        playlist_name,\n        playlist_id,\n        playlist_followers,\n        playlist_position,\n        track_name,\n        track_uri,\n        artist_name,\n        artist_uri,\n        album_name,\n        album_uri,\n        duration_ms\n      ) |&gt;\n      rename(\n        track_id  = track_uri,\n        artist_id = artist_uri,\n        album_id  = album_uri,\n        duration  = duration_ms\n      )\n  })\n  \n  return(playlist_tracks)\n}\n\n# Load playlists data\nplaylists_data &lt;- load_playlist()\n# glimpse(playlists_data)\n# head(playlists_data)\n# View(playlists_data)\n\n#‘Rectangle’ the Playlist Data\n#Convert the playlist data into the rectangle format, which is a tidy data frame with one row per track in a playlist.\nstrip_spotify_prefix &lt;- function(x){\n  library(stringr)\n  str_extract(x, \".*:.*:(.*)\", group=1)\n}\n\nplaylists_data &lt;- playlists_data |&gt;\n  mutate(\n    track_id  = sapply(track_id, strip_spotify_prefix),\n    artist_id = sapply(artist_id, strip_spotify_prefix),\n    album_id  = sapply(album_id, strip_spotify_prefix)\n  )\n# View(playlists_data)\n\n#create a kabble of the first 10 rows of the playlist data\nkable(playlists_data[1:10,])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplaylist_name\nplaylist_id\nplaylist_followers\nplaylist_position\ntrack_name\ntrack_id\nartist_name\nartist_id\nalbum_name\nalbum_id\nduration\n\n\n\n\nThrowbacks\n0\n1\n1\nLose Control (feat. Ciara & Fat Man Scoop)\n0UaMYEvWZi0ZqiDOoHU3YI\nMissy Elliott\n2wIVse2owClT7go1WT98tk\nThe Cookbook\n6vV5UrXcfyQD1wu4Qo2I9K\n226863\n\n\nThrowbacks\n0\n1\n2\nToxic\n6I9VzXrHxO9rA9A5euc8Ak\nBritney Spears\n26dSoYclwsYLMAKD3tpOr4\nIn The Zone\n0z7pVBGOD7HCIB7S8eLkLI\n198800\n\n\nThrowbacks\n0\n1\n3\nCrazy In Love\n0WqIKmW4BTrj3eJFmnCKMv\nBeyoncé\n6vWDO969PvNqNYHIOW5v0m\nDangerously In Love (Alben für die Ewigkeit)\n25hVFAxTlDvXbx2X2QkUkE\n235933\n\n\nThrowbacks\n0\n1\n4\nRock Your Body\n1AWQoqb9bSvzTjaLralEkT\nJustin Timberlake\n31TPClRtHm23RisEBtV3X7\nJustified\n6QPkyl04rXwTGlGlcYaRoW\n267266\n\n\nThrowbacks\n0\n1\n5\nIt Wasn’t Me\n1lzr43nnXAijIGYnCT8M8H\nShaggy\n5EvFsr3kj42KNv97ZEnqij\nHot Shot\n6NmFmPX56pcLBOFMhIiKvF\n227600\n\n\nThrowbacks\n0\n1\n6\nYeah!\n0XUfyU2QviPAs6bxSpXYG4\nUsher\n23zg3TcAtWQy7J6upgbUnj\nConfessions\n0vO0b1AvY49CPQyVisJLj0\n250373\n\n\nThrowbacks\n0\n1\n7\nMy Boo\n68vgtRHr7iZHpzGpon6Jlo\nUsher\n23zg3TcAtWQy7J6upgbUnj\nConfessions\n1RM6MGv6bcl6NrAG8PGoZk\n223440\n\n\nThrowbacks\n0\n1\n8\nButtons\n3BxWKCI06eQ5Od8TY2JBeA\nThe Pussycat Dolls\n6wPhSqRtPu1UhRCDX5yaDJ\nPCD\n5x8e8UcCeOgrOzSnDGuPye\n225560\n\n\nThrowbacks\n0\n1\n9\nSay My Name\n7H6ev70Weq6DdpZyyTmUXk\nDestiny’s Child\n1Y8cdNmUJH7yBTd9yOvr5i\nThe Writing’s On The Wall\n283NWqNsCA9GwVHrJk59CG\n271333\n\n\nThrowbacks\n0\n1\n10\nHey Ya! - Radio Mix / Club Mix\n2PpruBYCo4H7WOBJ7Q2EwM\nOutKast\n1G9G7WwrXka3Z1r7aIDjI7\nSpeakerboxxx/The Love Below\n1UsmQ3bpJTyK6ygoOOjG1r\n235213\n\n\n\n\n\n\n\n\n\n\nWith a imported and cleaned dataset, we can now begin to explore the data.\n\n\nHow many distinct tracks and artists are represented in the playlist data?\n\nThere are 9,745 distinct artists and 34,443 distinct tracks in the playlist data.The following table shows the distinct artists in the playlist.\n\n\nCode\nlibrary(dplyr)\nlibrary(knitr)\nlibrary(kableExtra)\n#Count the number of distinct artists and tracks\ndistinct_artists &lt;- playlists_data |&gt;\n  distinct(artist_id) |&gt;\n  summarise(\"Number of Artists\" = n())\n#print(distinct_artists)\n\n#create a kable of distinct artists\nkable(distinct_artists)\n\n\n\n\n\nNumber of Artists\n\n\n\n\n9754\n\n\n\n\n\n The following table shows the distinct tracks in the playlist data set.\n\n\nCode\n#Count the number of distinct tracks\ndistinct_tracks &lt;- playlists_data |&gt;\n  distinct(track_id) |&gt;\n  summarise(\"Number of Tracks\" = n())\n#print(distinct_tracks)\n\n#create a kable of distinct tracks\nkable(distinct_tracks)\n\n\n\n\n\nNumber of Tracks\n\n\n\n\n34443\n\n\n\n\n\n\n\nWhat are the 5 most popular tracks in the playlist data?\nThe most popular track is Closer which made 75 appearances in the playlist data.\n\n The following table shows the 5 most popular tracks in the playlist data.\n\n\nCode\n# Find the most popular tracks\nmost_popular_tracks &lt;- playlists_data |&gt;\n  group_by(track_name) |&gt;\n  summarise(`Number of Appearances` = n()) |&gt;\n  arrange(desc(`Number of Appearances`)) |&gt;\n  slice(1:5) |&gt;\n  rename(\"Name of Track\" = track_name) \n#print(most_popular_tracks)\n#View(most_popular_tracks)\n\n# Create a kable of the most popular tracks\nkable(most_popular_tracks)\n\n\n\n\n\nName of Track\nNumber of Appearances\n\n\n\n\nCloser\n75\n\n\nOne Dance\n55\n\n\nHUMBLE.\n52\n\n\nRide\n52\n\n\nBroccoli (feat. Lil Yachty)\n50\n\n\n\n\n\n\n\nWhat is the most popular track in the playlist data that does not have a corresponding entry in the song characteristics data?\nThe most popular track that does not have a corresponding entry in the song characteristics data is One Dance by Drake. It appears 55 times in the playlist data and is shockingly not in the song characteristics data set for it’s danceability.\n\n\n\n\nCode\n#join data frames by track id column\nsong_data &lt;- song_data |&gt;\n  rename(\"track_id\" = id)\n\n#Find the most popular track that has no entry in song  data\nno_match_tracks &lt;- playlists_data |&gt;\n  anti_join(song_data, by = \"track_id\") \n\nmost_pop_nochar &lt;- (\n  no_match_tracks |&gt;\n    count(`Name of Track`= track_name, `Artist` = artist_name, sort = TRUE) |&gt;\n    slice_max(n, n = 1) |&gt;\n    rename(`Number of Appearances` = n)\n)\n\n#View(most_pop_nochar)\n\n# Create a kable of the most popular track without characteristics\nkable(most_pop_nochar)\n\n\n\n\n\nName of Track\nArtist\nNumber of Appearances\n\n\n\n\nOne Dance\nDrake\n55\n\n\n\n\n\n 4. According to the song characteristics data, what is the most “danceable” track? How often does it appear in a playlist?\nThe most danceable track is Tone-Loc's Funky Cold Medina. It appears one time in the playlist titled ***VACATION*** and has a danceability score that is closest to 1.\n\n\nCode\n# use left join to combine the song data with the playlist data\njoin_data &lt;- song_data |&gt;\n  left_join(playlists_data, by = \"track_id\")\n\n# Find the most danceable track\nmost_danceable_track &lt;- join_data |&gt;\n  select(track_name, artist_name, danceability, playlist_name) |&gt;\n  arrange(desc(danceability)) |&gt;\n  rename(\"Name of Track\" = track_name, \"Artist\" = artist_name, \"Danceability\" = danceability, \"Playlist Name\" = playlist_name) |&gt;\n  slice(1)\n\n#View(most_danceable_track)\n\n# Create a kable table to display the most danceable track\nkable(most_danceable_track)\n\n\n\n\n\nName of Track\nArtist\nDanceability\nPlaylist Name\n\n\n\n\nFunky Cold Medina\nTone-Loc\n0.988\nVACATION\n\n\n\n\n\n\n\nWhich playlist has the longest average track length?\nThe playlist with the longest average track length is the Classical playlist. It’s average track length is approximately 411148.7 milliseconds or 7 minutes.\n\n\n\nCode\n# Find the playlist with the longest average track length by grouping by playlist name \n# and calculating the average track length (average of the duration column).\n# Then, calculate the average length in minutes and sort the data frame in descending order.\n#names(playlists_data)\nlongest_playlist &lt;- playlists_data |&gt;\n  group_by(playlist_name) |&gt;\n  summarise(avg_length = mean(duration)) |&gt;\n  mutate(avg_length_min = round(avg_length/60000, 0)) |&gt;\n  arrange(desc(avg_length)) |&gt;\n  rename(\"Playlist Name\" = playlist_name, \"Average Track Length (ms)\" = avg_length, \"Average Track Length (min)\" = avg_length_min) |&gt;\n  slice(1)\n#View(longest_playlist)\n\n# Create a kable Extra table to display the playlist with the longest average track length\nkable(longest_playlist)\n\n\n\n\n\nPlaylist Name\nAverage Track Length (ms)\nAverage Track Length (min)\n\n\n\n\nclassical\n411148.7\n7\n\n\n\n\n\n\n\nWhat is the most popular playlist on Spotify?\nThe most popular playlist on Spotify is Tangled with 1038 followers.\n\n\n\nCode\n#Find the most popular playlist by grouping by playlist id and name and number of followers\nmost_popular_playlist &lt;- playlists_data |&gt;\n  distinct(playlist_id, playlist_name, playlist_followers) |&gt;\n  slice_max(playlist_followers) |&gt;\n  rename(\"Playlist ID\" = playlist_id,\"Playlist Name\" = playlist_name, \"Number of Followers\" = playlist_followers) \n#View(most_popular_playlist)\n\n# Create a kable table to display the most popular playlist\n\nkable(most_popular_playlist)\n\n\n\n\n\nPlaylist ID\nPlaylist Name\nNumber of Followers\n\n\n\n\n765\nTangled\n1038\n\n\n\n\n\n\n\n\n\n\nNext, we will conduct a more in-depth analysis of the most popular songs in the data set using INNER_JOIN to combine the song data with the playlist data set. We will use ggplot2 to visualize the data.\n\n\nIs the popularity column correlated with the number of playlist appearances? If so, to what degree?\nThe following plot shows the correlation between the popularity and the number of playlist appearances. The correlation is positive, indicating that as the popularity increases, the number of playlist appearances also increases. The thresholds are set at 0-25 for Low and 25-75 for Medium and 75-100 for High for mean popularity.\n\n\n\n\nCode\n#use inner join to combine the song data with the playlist data\ninner_join_data &lt;- song_data |&gt;\n  inner_join(playlists_data, by = \"track_id\")\n\n#using the inner join data find the correlation between the popularity and the number of playlist appearances\npop_correlation &lt;- inner_join_data |&gt;\n  group_by(track_id, track_name) |&gt;\n  summarise(num_of_playlists = n(),\n            mean_popularity = mean(popularity),\n            .groups = \"drop\") \n\n#create a new column to categorize the popularity into groups (Low, Medium, High)\n\npop_correlation &lt;- pop_correlation |&gt;\n  mutate(popularity_group = cut(\n    mean_popularity,\n    breaks = c(0, 25, 75, 100),\n    labels = c(\"Low\", \"Medium\", \"High\"),\n    include.lowest = TRUE\n  ))\n#View(pop_correlation)\n\n# Create a boxplot to display the popularity groups and their average playlist appearances\nlibrary(ggplot2)\nggplot(pop_correlation, aes(x = popularity_group, y = num_of_playlists)) +\n  geom_jitter(width = 0.2, alpha = 0.4, color = \"blue\") +\n  labs(\n    title = \"Playlist Appearances by Popularity Group\",\n    x = \"Popularity Group\",\n    y = \"Number of Playlist Appearances\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\nIn what year were the most popular songs released?.\nThe most popular songs were released in 2017. The highest average popularity of released songs was approximately 70.79.\n\n\n\nCode\n#Using the inner join data and mean, we will filter the data to find the most popular songs released in a distinct year.\npop_year &lt;- inner_join_data |&gt;\n  group_by(year) |&gt;\n  summarise(mean_pop_songs = mean(popularity, na.rm = TRUE)) |&gt;\n  arrange(desc(mean_pop_songs))\n\n#head(pop_year)\ntop_ten_pop_year &lt;- pop_year |&gt;\n  slice_head(n=10)\n#create kable of the most popular songs released in a distinct year\nkable(top_ten_pop_year) \n\n\n\n\n\nyear\nmean_pop_songs\n\n\n\n\n2017\n70.78972\n\n\n1976\n69.37306\n\n\n2016\n67.92846\n\n\n1983\n67.48315\n\n\n1982\n67.05217\n\n\n1980\n66.93662\n\n\n1981\n66.90955\n\n\n1979\n66.62581\n\n\n1967\n66.18493\n\n\n1973\n66.00585\n\n\n\n\n\nCode\n#View(pop_year)\n\n#visualize the average popularity of songs by year\npop_year_plot &lt;- ggplot(pop_year, aes(x = year, y = mean_pop_songs)) +\n  geom_line(color = \"blue\") +\n  geom_point(color = \"purple\") +\n  labs(title = \" Average Popularity of Released Songs by Year\",\n       x = \"Year\",\n       y = \"Average Popularity\")\nprint(pop_year_plot)\n\n\n\n\n\n\n\n\n\n\n\nIn what year did danceability peak?\nThe year with the highest average danceability is 2017. The average danceability for that year is 0.71.\n\n\n\nCode\n# Using the inner join data, we will filter the data to find the year with the highest average danceability.\ndanceability_year &lt;- inner_join_data |&gt;\n  group_by(year) |&gt;\n  summarise(mean_danceability = mean(danceability, na.rm = TRUE)) |&gt;\n  slice_max(mean_danceability, n = 1) |&gt;\n  rename(\"Average Danceability\" = mean_danceability)\n  \n#View(danceability_year)\n\n#create a kable of the year with the highest average danceability\n\nkable(danceability_year)\n\n\n\n\n\nyear\nAverage Danceability\n\n\n\n\n2017\n0.7120776\n\n\n\n\n\nCode\n#data to view all average danceability by year\ndanceability_year_all &lt;- inner_join_data |&gt;\n  group_by(year) |&gt;\n  summarise(mean_danceability = mean(danceability, na.rm = TRUE)) |&gt;\n  arrange(desc(mean_danceability)) \n\n#visualize the average danceability of songs by year using a line plot\ndanceability_year_plot &lt;- ggplot(danceability_year_all, aes(x = year, y = mean_danceability)) +\n  geom_line(color = \"deepskyblue\") +\n  geom_point(color = \"black\") +\n  labs(title = \"Average Danceability by Year\",\n       x = \"Year\",\n       y = \"Average Danceability\")\nprint(danceability_year_plot)\n\n\n\n\n\n\n\n\n\n\n\nWhich decade is most represented on user playlists?\nThe decade with the most songs is the 2010s. The number of 2010 songs on most users playlist at that time was 24,713.\n\n\n\nCode\n#Mutate a column to calculate the decade using integer division\npop_decade &lt;- inner_join_data |&gt;\n  mutate(decade = (year %/% 10) * 10) |&gt;\n  group_by(decade) |&gt;\n  summarise(num_songs = n()) |&gt;\n  arrange(desc(num_songs)) |&gt;\n  rename(\"Number of Songs\" = num_songs, \"Decade\" = decade)\n\n#View(pop_decade)\n# Create a kable Extra table to display the number of songs by decade\nkable(pop_decade)\n\n\n\n\n\nDecade\nNumber of Songs\n\n\n\n\n2010\n24713\n\n\n2000\n7291\n\n\n1990\n3069\n\n\n1980\n1573\n\n\n1970\n1501\n\n\n1960\n735\n\n\n1950\n93\n\n\n1940\n38\n\n\n1930\n2\n\n\n\n\n\nCode\n# Create a bar plot to visualize the number of songs by decade\npop_decade_plot &lt;- ggplot(pop_decade, aes(x = factor(`Decade`), y = `Number of Songs`)) +\n  geom_bar(stat = \"identity\", fill = \"purple\", color = \"black\") +\n  labs(title = \"Number of Songs by Decade\",\n       x = \"Decade\",\n       y = \"Number of Songs\") +\n  theme_minimal()\n\nprint(pop_decade_plot)\n\n\n\n\n\n\n\n\n\n\n\nPlotting the key frequency among songs\nThe most common key is the 0 and 1 keys. The frequency of those key is more than 1,000.\n\n\n\nCode\n# Calculate the frequency of each key\nkey_frequency &lt;- inner_join_data |&gt;\n  group_by(key) |&gt;\n  summarize(count = n()) |&gt;\n  arrange(desc(count))\n\n# Create a polar plot...\nggplot(key_frequency, aes(x = as.factor(key), y = count)) +\n  geom_bar(stat = \"identity\", fill = \"darkgreen\", color = \"black\") +\n  coord_polar(start = 0) +\n  theme_bw() +\n  labs(title = \"Frequency of Musical Keys\",\n       x = \"Key\",\n       y = \"Count of Keys\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1),\n        axis.text = element_text(size = 12),\n        axis.title = element_text(size = 14),\n        plot.title = element_text(size = 16))\n\n\n\n\n\n\n\n\n\n\n\nWhat are the most popular track lengths?\nThe following histogram shows the distribution of track lengths. The most common track length is between 2 and 4 minutes.\n\n\n\nCode\n#using the inner join data, we will filter the data to find the most popular track lengths (in minutes)\ninner_join_data&lt;- inner_join_data |&gt;\n  mutate(track_length = duration/ 60000)\n\n#find the mean, median, min, and max track lengths\ntrack_length_data &lt;- inner_join_data |&gt;\n  summarise(\n    avg_length = mean(track_length, na.rm = TRUE),\n    median_length = median(track_length, na.rm = TRUE),\n    min_length = min(track_length, na.rm = TRUE),\n    max_length = max(track_length, na.rm = TRUE)\n  ) \n#View(track_length_data)\n#Create a kable table to display the track length data\nkable(track_length_data)\n\n\n\n\n\navg_length\nmedian_length\nmin_length\nmax_length\n\n\n\n\n3.974142\n3.833333\n0.0034333\n37.31222\n\n\n\n\n\nCode\n#Create a histogram to visualize the distribution of track lengths\nggplot(inner_join_data, aes(x = track_length)) +\n  geom_histogram(binwidth = 0.6, fill = \"cornflowerblue\", color = \"black\") +\n  labs(title = \"Most Popular Track Lengths\",\n       x = \"Track Length (minutes)\",\n       y = \"Number of Songs\") +\n  theme_bw() +\n  scale_x_continuous(\n    limits = c(0, 10),       # Only min and max go here\n    breaks = seq(0, 10, 2)   # Add ticks every 2 minutes\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow that exploring the data is finished we can build the playlist! First, we picked two anchor songs from the playlist data set: Wake Me Up When September Ends by Green Day and Fix You by Coldplay. Then, we found songs that work well in the playlist using heuristics.\n\n\n\n\n\nWhat other songs commonly appear on playlists along side this song?\n\n\n\nCode\n#Using inner join data we will filter the data to find the anchor songs and their characteristics. \nanchor_songs &lt;- inner_join_data |&gt;\n  filter(track_name %in% c(\"Wake Me Up When September Ends\", \"Fix You\")) |&gt; \n  distinct(track_id, track_name, artist_name, key, tempo, year, popularity, acousticness, danceability, valence, instrumentalness,energy)\n#View(anchor_songs)\n\n#distinct(inner_join_data, track_name) |&gt; View()\n\n#Heuristic 1: Songs that Commonly Appear with the Anchor Song\n#We'll find songs that appeared in the same playlists as the anchor song(s).\n\nanchor_ids &lt;- anchor_songs$track_id\n\nco_occurring_tracks &lt;- playlists_data |&gt;\n  filter(track_id %in% anchor_ids) |&gt;\n  select(playlist_id) |&gt;\n  inner_join(playlists_data, by = \"playlist_id\") |&gt;\n  filter(!track_id %in% anchor_ids) |&gt;  # exclude the anchor itself\n  count(track_name, artist_name, sort = TRUE) |&gt;\n  slice_max(n, n = 20)\n# Rename columns for clarity\n\nco_occurring_tracks &lt;- co_occurring_tracks |&gt;\n  rename(\n    `Track Name` = track_name,\n    `Artist Name` = artist_name,\n    `Number of Playlists` = n\n  )\n\n#View(co_occurring_tracks)\ntop_ten_co_ocurring &lt;- co_occurring_tracks |&gt;\n  slice_head(n = 10)\n# Create a kable table to display the similar co-occuring tracks\nkable(top_ten_co_ocurring) \n\n\n\n\n\n\n\n\n\n\nTrack Name\nArtist Name\nNumber of Playlists\n\n\n\n\nChasing Cars\nSnow Patrol\n9\n\n\nDrops of Jupiter\nTrain\n8\n\n\nI Write Sins Not Tragedies\nPanic! At The Disco\n7\n\n\nYellow\nColdplay\n7\n\n\n21 Guns\nGreen Day\n6\n\n\nMr. Brightside\nThe Killers\n6\n\n\nShe Will Be Loved - Radio Mix\nMaroon 5\n6\n\n\nThe Scientist\nColdplay\n6\n\n\nHoliday/Boulevard Of Broken Dreams\nGreen Day\n5\n\n\nHow to Save a Life\nThe Fray\n5\n\n\n\n\n\n\n\nWhat other songs are in the same key and have a similar tempo?\n\nThe following table shows the songs that are in the same key and have a similar tempo to the anchor songs. The tempo is between 5 BPM of the anchor songs.\n\n\nCode\n################\n#Heuristic 2: Same Key + Similar Tempo (±5 BPM)\nlibrary(purrr)\nsimilar_key_tempo &lt;- inner_join_data |&gt;\n  filter(\n    key %in% anchor_songs$key,\n    map_lgl(tempo, ~ any(abs(.x - anchor_songs$tempo) &lt;= 5))\n  ) |&gt;\n  distinct(track_id, track_name, artist_name, tempo, key)|&gt;\n  slice_max(tempo, n = 15) # Get top 10 similar tracks\n\n# Rename columns for clarity\nsimilar_key_tempo &lt;- similar_key_tempo |&gt;\n  rename(\n    `Track Name` = track_name,\n    `Artist Name` = artist_name,\n    `Tempo (BPM)` = tempo,\n    `Key` = key\n  )\n\n#View(similar_key_tempo)\ntop_ten_keytemp &lt;- similar_key_tempo  |&gt;\n  slice_head(n = 10)\n# Create a kable table to display the similar key tempo tracks\nkable(top_ten_keytemp) \n\n\n\n\n\n\n\n\n\n\n\n\ntrack_id\nTrack Name\nArtist Name\nTempo (BPM)\nKey\n\n\n\n\n71tjsDvB4EMJqNG8EMmFnb\nComin’ Home Baby\nMel Tormé\n143.121\n7\n\n\n1f2lkuLldqRzvaFjJdjGXX\nSanta Claus Is Comin’ to Town\nMariah Carey\n143.109\n7\n\n\n4NTWZqvfQTlOMitlVn6tew\nThe Show Goes On\nLupe Fiasco\n143.067\n7\n\n\n10eDxSTjwMBq1ZjZK5b1cK\nMillennia\nCrown The Empire\n143.036\n3\n\n\n2rUwQj4SWaP2anuGDtNpYR\nSelf-Made\nBryson Tiller\n143.001\n7\n\n\n0UDCfleTgwihlnOUxbzokR\nAwake\nBTS\n142.816\n3\n\n\n6NGi23FFKq9tH5NR1NcTw2\nLet Her Cry\nHootie & The Blowfish\n142.570\n7\n\n\n3403qFGo7u2ptUyJbdEkjI\nFor the Widows in Paradise, For the Fatherless in Ypsilanti\nSufjan Stevens\n142.433\n3\n\n\n4F55RCGuM477OjznpYGhYz\nShortie Like Mine\nBow Wow\n142.149\n7\n\n\n7g8OpS827dAYU067lZaR0L\nJust a Dream\nCarrie Underwood\n142.060\n7\n\n\n\n\n\n\n\nWhat other songs were released by the same artists?\n\n\n\nCode\n#Heuristic 3: Same Artist\nsame_artist_tracks &lt;- inner_join_data |&gt;\n  filter(artist_name %in% anchor_songs$artist_name) |&gt;\n  distinct(track_id, track_name, artist_name)\n\n#View(same_artist_tracks)\n# Create a kable Extra table to display the same artist tracks\n\ntop_ten_same &lt;- same_artist_tracks |&gt;\n  slice_head(n = 10)\n\nkable(top_ten_same) \n\n\n\n\n\ntrack_id\ntrack_name\nartist_name\n\n\n\n\n31L9yLXSj6LpCFupyMV6CR\nUp&Up\nColdplay\n\n\n5qfZRNjt2TkHEL12r3sDEU\nEverglow\nColdplay\n\n\n4ZcnZVXwLDLWI93SLJER3a\nMisery\nGreen Day\n\n\n1rkbMXhEjIytsUGbhoR5pn\nLife In Technicolor\nColdplay\n\n\n1qIgyDoc2rwtq8w49jeWL8\nOh Love\nGreen Day\n\n\n6f49kbOuQSOsStBpyGvQfA\nA Head Full Of Dreams\nColdplay\n\n\n6FnDerFHdaeCFovZnQ3r14\nLast Ride In\nGreen Day\n\n\n3KzCJGegAcwsSik1bOgkNu\nWords I Might Have Ate\nGreen Day\n\n\n6c6W25YoDGjTq3qSPOga5t\nInk\nColdplay\n\n\n3HWDWyIqWuLsTHECx9DvXF\nBirds\nColdplay\n\n\n\n\n\n\n\nWhat other songs were released in the same year and have similar levels of acousticness and danceability?\n\nWe’ll allow a range (±0.1) around the acousticness/danceability of the anchor songs.\n\n\nCode\n# heuristic 4 - \n# We'll allow a range (±0.1) around the acousticness/danceability of the anchor songs.\n#find the range of years for the anchor songs\n#and filter the data to find the similar songs\n\n\nanchor_range &lt;- anchor_songs |&gt;\n  summarise(\n    min_acoustic = min(acousticness) - 0.1,\n    max_acoustic = max(acousticness) + 0.1,\n    min_dance = min(danceability) - 0.1,\n    max_dance = max(danceability) + 0.1,\n    year_range = list(unique(year))  # make year_range a list-column\n  )\n\n# Pull the scalar values from the 1-row data frame\nmin_acoustic &lt;- anchor_range$min_acoustic\nmax_acoustic &lt;- anchor_range$max_acoustic\nmin_dance &lt;- anchor_range$min_dance\nmax_dance &lt;- anchor_range$max_dance\nyear_range &lt;- anchor_range$year_range[[1]]  # unlist the year_range safely\n\n# Now filter safely\nsimilar_vibe_tracks &lt;- inner_join_data |&gt;\n  filter(\n    year %in% year_range,\n    acousticness &gt;= min_acoustic,\n    acousticness &lt;= max_acoustic,\n    danceability &gt;= min_dance,\n    danceability &lt;= max_dance\n  ) |&gt;\n  distinct(track_id, track_name, artist_name, year)\n\n\n#View(similar_vibe_tracks)\ntop_ten_vibe &lt;- similar_vibe_tracks |&gt;\n  slice_head(n = 10)\n\n#create a kable table to display the similar vibe tracks\nkable(top_ten_vibe)\n\n\n\n\n\n\n\n\n\n\n\ntrack_id\ntrack_name\nartist_name\nyear\n\n\n\n\n28jOIJzouTp7gqhtx7RbGa\nBlame It On Bad Luck\nBayside\n2005\n\n\n4e4vO6bp5nSdP9G79O3qS6\nMiss Me Baby\nChris Cagle\n2005\n\n\n2YxoC2dYOotjqt08dEifsc\nChromakey Dreamcoat\nBoards of Canada\n2005\n\n\n2itu79WbZhUCHX4jg0fyAd\nNever Let This Go\nParamore\n2005\n\n\n53Qpn8LPa0IhFCTiPO0Bbm\nI Disappear\nThe Faint\n2004\n\n\n0L639McB94IkUvIgZKM1E5\nPirates\nBullets And Octane\n2004\n\n\n5fHkJ1a7v0JFPiT9rFQI8U\nTe Daré Lo Mejor\nJesús Adrián Romero\n2004\n\n\n6u84UiQ3TRczfYTDVYrz7S\nSomeone That You’re With\nNickelback\n2005\n\n\n433JymbpWnRMHXzp1oTRP7\nDon’t Bother\nShakira\n2005\n\n\n4sjjV02cN3nDOIZPJabEgM\nThe Time Is Now\nJohn Cena\n2005\n\n\n\n\n\n\n\nWhat other songs were released have similar levels of valence?\n\n\n\nCode\n#Valence(Mood) or emotional tone of the track\n# names(anchor_songs)\n#We will use the valence column to find similar songs\nvalence_range &lt;- anchor_songs |&gt; summarise(\n  min_valence = min(valence) - 0.001,\n  max_valence = max(valence) + 0.001\n)\n#compare  the valence of the anchor songs to the valence of the other songs\nsimilar_valence_tracks &lt;- inner_join_data |&gt;\n  filter(\n    valence &gt;= valence_range$min_valence,\n    valence &lt;= valence_range$max_valence\n  ) |&gt;\n  distinct(track_id, track_name, artist_name, valence)\n\n# Rename columns for clarity\nsimilar_valence_tracks &lt;- similar_valence_tracks |&gt;\n  rename(\n    `Track Name` = track_name,\n    `Artist Name` = artist_name,\n    `Valence` = valence\n  )\n\n#View(similar_valence_tracks)\ntop_ten_valence &lt;- similar_valence_tracks |&gt;\n  slice_head(n = 10)\n# Create a kable table to display the similar valence tracks\nkable(top_ten_valence) \n\n\n\n\n\n\n\n\n\n\n\ntrack_id\nTrack Name\nArtist Name\nValence\n\n\n\n\n3lpa6fzS3rSAbRogEhWxu7\nStar Spangled Banner - Live at Woodstock\nJimi Hendrix\n0.129\n\n\n1YBf7Tq9bpcVwvnlP8YbQS\nYear Zero\nGhost B.C.\n0.137\n\n\n52WTLETEHs5jwCr7LCq0VW\nQueen\nPerfume Genius\n0.130\n\n\n5qfZRNjt2TkHEL12r3sDEU\nEverglow\nColdplay\n0.136\n\n\n0WCbhE2evMrIwRM0DlMy9k\nMixtape (feat. Young Thug & Lil Yachty)\nChance The Rapper\n0.126\n\n\n5eG8QuQKOBvDeCyoOeMkhT\nAlps\nNovo Amor\n0.135\n\n\n7hmdJhc4W0idVVoMES7F9F\nIf I Know Me\nGeorge Strait\n0.146\n\n\n4qKDjmz094Bu2wMepNuwVN\nMain Title / Once Upon A Dream / Prologue - From “Sleeping Beauty” Soundtrack\nChorus - Sleeping Beauty\n0.143\n\n\n1fckqKAI9ug7U1DgQrrOop\nBelieve It - feat. Rick Ross\nMeek Mill\n0.138\n\n\n0st2C7aLz9xkr7JyshhUHK\nScandal of Grace\nHillsong United\n0.138\n\n\n\n\n\n\n\n\n\n\n\nThe following playlist is comprised of the offical 12 candidates selected for the playlist before ordering. It was created using all four heurtics above to find songs of similar standing as the chosen anchor songs. Additionally, it’s comprised of 2 songs that I was not familiar with, I Disappear and Chromakey Dreamcoat. This means that the playlist is also pretty diverse in terms of popularity.\n\n\n\nCode\n#final Playlist Candidate\n#Now combine all those results and filter down to at least 20 unique songs, making sure at least 8 are not “popular” (say, popularity &lt; 60)\nanchor_artists &lt;- unique(anchor_songs$artist_name)\nanchor_ids &lt;- unique(anchor_songs$track_id)\nall_candidates &lt;- bind_rows(\n  co_occurring_tracks,\n  similar_key_tempo,\n  similar_vibe_tracks,\n  similar_valence_tracks\n) |&gt;\n  filter(!artist_name %in% anchor_artists) |&gt;\n  distinct(track_id, track_name, artist_name)\n\n# Join with popularity info\nfinal_candidates &lt;- all_candidates |&gt;\n  inner_join(inner_join_data |&gt; select(track_name, artist_name, popularity,valence,energy,danceability), by = c(\"track_name\", \"artist_name\")) |&gt;\n  distinct() |&gt;\n  mutate(\n    is_popular = ifelse(popularity &gt;= 60, \"Not Popular\", \"Popular\"))\npopular_split &lt;- final_candidates |&gt;\n  group_split(is_popular)\n\nnon_popular &lt;- popular_split[[which(levels(as.factor(final_candidates$is_popular)) == \"Not Popular\")]] |&gt;\n  slice_head(n = 4)\n\npopular &lt;- popular_split[[which(levels(as.factor(final_candidates$is_popular)) == \"Popular\")]] |&gt;\n  slice_head(n = 6)\n\nfinal_playlist &lt;- bind_rows(non_popular, popular)\n\n# Select relevant columns from anchor_songs\nanchor_clean &lt;- anchor_songs |&gt;\n  select(track_id, track_name, artist_name, popularity, valence, energy, danceability)\n\n# Combine with the rest of the playlist\nfinal_playlist &lt;- bind_rows(final_playlist, anchor_clean) |&gt;\n  distinct(track_id, .keep_all = TRUE) # Avoid duplicates\n\nkable(final_playlist)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrack_id\ntrack_name\nartist_name\npopularity\nvalence\nenergy\ndanceability\nis_popular\n\n\n\n\n2JdhRRTl3ee6pQQupVQqyb\nHow Great Is Our God\nChris Tomlin\n63\n0.0765\n0.573\n0.318\nNot Popular\n\n\n7oK9VyNzrYvRFo7nQEYkWN\nMr. Brightside\nThe Killers\n78\n0.2320\n0.924\n0.356\nNot Popular\n\n\n5oQcOu1omDykbIPSdSQQNJ\n1985\nBowling For Soup\n70\n0.9030\n0.887\n0.606\nNot Popular\n\n\n7lRlq939cDG4SzWOF4VAnd\nI’m Not Okay (I Promise)\nMy Chemical Romance\n73\n0.2550\n0.940\n0.210\nNot Popular\n\n\n28jOIJzouTp7gqhtx7RbGa\nBlame It On Bad Luck\nBayside\n44\n0.4140\n0.692\n0.323\nPopular\n\n\n4e4vO6bp5nSdP9G79O3qS6\nMiss Me Baby\nChris Cagle\n43\n0.3570\n0.569\n0.526\nPopular\n\n\n2YxoC2dYOotjqt08dEifsc\nChromakey Dreamcoat\nBoards of Canada\n50\n0.7660\n0.825\n0.643\nPopular\n\n\n2itu79WbZhUCHX4jg0fyAd\nNever Let This Go\nParamore\n49\n0.5290\n0.880\n0.519\nPopular\n\n\n53Qpn8LPa0IhFCTiPO0Bbm\nI Disappear\nThe Faint\n45\n0.6770\n0.860\n0.627\nPopular\n\n\n0L639McB94IkUvIgZKM1E5\nPirates\nBullets And Octane\n51\n0.7580\n0.907\n0.521\nPopular\n\n\n3ZffCQKLFLUvYM59XKLbVm\nWake Me Up When September Ends\nGreen Day\n76\n0.1460\n0.814\n0.546\nNA\n\n\n7LVHVU3tWfcxj5aiPFEW4Q\nFix You\nColdplay\n81\n0.1240\n0.417\n0.209\nNA"
  },
  {
    "objectID": "mp03.html#design-principles",
    "href": "mp03.html#design-principles",
    "title": "Mini Project 3",
    "section": "",
    "text": "Using a statistics-based approach, we explored trends in popularity, danceability, energy, valence, track length, and more. By leveraging summary statistics, correlations, and visualizations, we identified key patterns that guided the creation of our desired playlist. The result is a carefully curated selection of tracks that authentically capture the vibe we aimed to achieve.\n\n\n\n\n\n\nBy employing a heuristic-based approach, the selection of songs for the playlist became more precise and intentional. The heuristics used include several key factors: songs that frequently co-occur in playlists alongside anchor tracks, tracks with similar key and tempo, selections from the same artists, songs with acousticness and danceability values within a defined range, and finally, tracks with a comparable valence (emotional tone). By integrating multiple heuristics, this approach effectively curates a playlist where musical and emotional cohesion is maintained, creating a multi-faceted filtering system that enhances meaningful discovery.\n\n\n\n\n\n\nBy prioritizing sonic cohesion, the playlist achieves a well-curated feel. Tracks are ordered based on valence (mood) and energy, ensuring a consistent emotional and rhythmic experience throughout. This approach maintains uniformity in both mood and tempo, enhancing the overall listening journey. Additionally, the visualization of the playlist serves as a validation of its progression, effectively illustrating the evolution of energy, danceability, and emotional tone."
  },
  {
    "objectID": "mp03.html#why-this-playlist-is-the-ultimate-playlistvisualization",
    "href": "mp03.html#why-this-playlist-is-the-ultimate-playlistvisualization",
    "title": "Mini Project 3",
    "section": "",
    "text": "We will be using the Spotify Million Playlist Dataset, which contains a large number of playlists and their associated tracks as well as a dataset of songs and their characteristics.\n\n\nCode\nensure_package &lt;- function(pkg) {\n  if (!requireNamespace(pkg, quietly = TRUE)) {\n    install.packages(pkg)\n  }\n  library(pkg, character.only = TRUE)\n}\n\n# Ensure the necessary packages are installed and loaded\nensure_package(\"dplyr\")\nensure_package(\"stringr\")\nensure_package(\"tidyr\")\nensure_package(\"httr2\")\nensure_package(\"rvest\")\nensure_package(\"datasets\")\nensure_package(\"purrr\")\nensure_package(\"DT\")\nensure_package(\"jsonlite\")\nensure_package(\"httr\")\n\n#Here we will load the song data from a CSV file (posted by Github User gabminamendez) \nload_songs &lt;- function() {\n  # Define file and directory paths\n  directory &lt;- \"data/mp03\"\n  file_url &lt;- \"https://raw.githubusercontent.com/gabminamedez/spotify-data/refs/heads/master/data.csv\"\n  file_path &lt;- file.path(directory, \"data.csv\")\n  \n  # Create the directory if it doesn't exist\n  if (!dir.exists(directory)) {\n    dir.create(directory, recursive = TRUE)\n  }\n  \n  # Download the file if it doesn't already exist\n  if (!file.exists(file_path)) {\n    download.file(file_url, file_path)\n    message(\"File downloaded: \", file_path)\n  } else {\n    message(\"File already exists: \", file_path)\n  }\n  \n  # Read the CSV file into a data frame\n  song_data &lt;- read.csv(file_path, stringsAsFactors = FALSE)\n  \n  # Process the artists column\n  clean_artist_string &lt;- function(x){\n    str_replace_all(x, \"\\\\['\", \"\") |&gt; \n      str_replace_all(\"'\\\\]\", \"\") |&gt;\n      str_replace_all(\" '\", \"\")\n  }\n  \n  # Process and return the data\n  processed_data &lt;- song_data |&gt; \n    separate_longer_delim(artists, \",\") |&gt;\n    mutate(artist = clean_artist_string(artists)) |&gt;\n    select(-artists)\n  \n  return(processed_data)\n}\n\n# Now actually call the function and save the result\nsong_data &lt;- load_songs()\n\n# View the first few rows to confirm it worked\n# head(song_data)\n# names(song_data)\n# \n# Next, we will load the playlist data from a JSON file (posted by Github User DevinOgrady)\n# Define the function to load the playlist data from the repository, store them locally, and return a tidy data frame to read them into R in a standardized format.\n\nload_playlist &lt;- function() {\n  p_directory &lt;- \"data/mp03/playlists\"\n  p_url &lt;- \"https://raw.githubusercontent.com/DevinOgrady/spotify_million_playlist_dataset/master/data1/\"\n  j_file_name &lt;- \"mpd.slice.0-999.json\"\n  file_path_1 &lt;- file.path(p_directory, j_file_name)\n  file_url_1 &lt;- paste0(p_url, j_file_name)\n  \n  if (!dir.exists(p_directory)) {\n    dir.create(p_directory, recursive = TRUE)\n  }\n  \n  if (!file.exists(file_path_1)) {\n    download.file(file_url_1, destfile = file_path_1, method = \"auto\")\n  }\n  \n  playlist_data &lt;- fromJSON(file_path_1, simplifyVector = FALSE)  \n  \n  if (!\"playlists\" %in% names(playlist_data)) return(NULL)\n  \n  playlist_tracks &lt;- map_dfr(playlist_data$playlists, function(pl) {\n    if (!is.list(pl)) return(NULL)\n    if (!(\"tracks\" %in% names(pl))) return(NULL)\n    if (!is.list(pl$tracks) || length(pl$tracks) == 0) return(NULL)\n    \n    tidy_data &lt;- tryCatch(\n      bind_rows(pl$tracks),\n      error = function(e) NULL\n    )\n    \n    if (is.null(tidy_data) || nrow(tidy_data) == 0) return(NULL)\n    \n    tidy_data |&gt;\n      mutate(\n        playlist_name      = pl$name,\n        playlist_id        = pl$pid,\n        playlist_followers = pl$num_followers,\n        playlist_position  = row_number()\n      ) |&gt;\n      select(\n        playlist_name,\n        playlist_id,\n        playlist_followers,\n        playlist_position,\n        track_name,\n        track_uri,\n        artist_name,\n        artist_uri,\n        album_name,\n        album_uri,\n        duration_ms\n      ) |&gt;\n      rename(\n        track_id  = track_uri,\n        artist_id = artist_uri,\n        album_id  = album_uri,\n        duration  = duration_ms\n      )\n  })\n  \n  return(playlist_tracks)\n}\n\n# Load playlists data\nplaylists_data &lt;- load_playlist()\nglimpse(playlists_data)\n\n\nRows: 67,503\nColumns: 11\n$ playlist_name      &lt;chr&gt; \"Throwbacks\", \"Throwbacks\", \"Throwbacks\", \"Throwbac…\n$ playlist_id        &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …\n$ playlist_followers &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ playlist_position  &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, …\n$ track_name         &lt;chr&gt; \"Lose Control (feat. Ciara & Fat Man Scoop)\", \"Toxi…\n$ track_id           &lt;chr&gt; \"spotify:track:0UaMYEvWZi0ZqiDOoHU3YI\", \"spotify:tr…\n$ artist_name        &lt;chr&gt; \"Missy Elliott\", \"Britney Spears\", \"Beyoncé\", \"Just…\n$ artist_id          &lt;chr&gt; \"spotify:artist:2wIVse2owClT7go1WT98tk\", \"spotify:a…\n$ album_name         &lt;chr&gt; \"The Cookbook\", \"In The Zone\", \"Dangerously In Love…\n$ album_id           &lt;chr&gt; \"spotify:album:6vV5UrXcfyQD1wu4Qo2I9K\", \"spotify:al…\n$ duration           &lt;int&gt; 226863, 198800, 235933, 267266, 227600, 250373, 223…\n\n\nCode\nhead(playlists_data)\n\n\n# A tibble: 6 × 11\n  playlist_name playlist_id playlist_followers playlist_position track_name     \n  &lt;chr&gt;               &lt;int&gt;              &lt;int&gt;             &lt;int&gt; &lt;chr&gt;          \n1 Throwbacks              0                  1                 1 Lose Control (…\n2 Throwbacks              0                  1                 2 Toxic          \n3 Throwbacks              0                  1                 3 Crazy In Love  \n4 Throwbacks              0                  1                 4 Rock Your Body \n5 Throwbacks              0                  1                 5 It Wasn't Me   \n6 Throwbacks              0                  1                 6 Yeah!          \n# ℹ 6 more variables: track_id &lt;chr&gt;, artist_name &lt;chr&gt;, artist_id &lt;chr&gt;,\n#   album_name &lt;chr&gt;, album_id &lt;chr&gt;, duration &lt;int&gt;\n\n\nCode\nView(playlists_data)\n\n#‘Rectangle’ the Playlist Data\n#Convert the playlist data into the rectangle format, which is a tidy data frame with one row per track in a playlist.\nstrip_spotify_prefix &lt;- function(x){\n  library(stringr)\n  str_extract(x, \".*:.*:(.*)\", group=1)\n}\n\nplaylists_data &lt;- playlists_data |&gt;\n  mutate(\n    track_id  = sapply(track_id, strip_spotify_prefix),\n    artist_id = sapply(artist_id, strip_spotify_prefix),\n    album_id  = sapply(album_id, strip_spotify_prefix)\n  )\nView(playlists_data)\n\n\n\n\n\nWith a imported and cleaned dataset, we can now begin to explore the data.  ### How many distinct tracks and artists are represented in the playlist data?\nThere are 9,745 distinct artists and 34,443 distinct tracks in the playlist data.\nThe following table shows the distinct artists in the playlist \n\n\nCode\nlibrary(dplyr)\nlibrary(knitr)\nlibrary(kableExtra)\n#Count the number of distinct artists and tracks\ndistinct_artists &lt;- playlists_data |&gt;\n  distinct(artist_id) |&gt;\n  summarise(\"Number of Artists\" = n())\nprint(distinct_artists)\n\n\n# A tibble: 1 × 1\n  `Number of Artists`\n                &lt;int&gt;\n1                9754\n\n\nThis table shows the distinct tracks in the playlist \n\n\nCode\n#Count the number of distinct tracks\ndistinct_tracks &lt;- playlists_data |&gt;\n  distinct(track_id) |&gt;\n  summarise(\"Number of Tracks\" = n())\nprint(distinct_tracks)\n\n\n# A tibble: 1 × 1\n  `Number of Tracks`\n               &lt;int&gt;\n1              34443"
  },
  {
    "objectID": "mp03.html#playlist-echoes-of-the-boulevard",
    "href": "mp03.html#playlist-echoes-of-the-boulevard",
    "title": "Mini Project 3",
    "section": "",
    "text": "The Ulitmate Playlist is Echoes of the Boulevard. It’s a playlist that is a collection of 12 songs that expresses the emotional journey of a person going thorugh the motions of life as waves of ups and down. It bridges the nostalic notes of Coldplay with the rebellious attitudes of Green Day. It’s your go to playlist for when you are staring out the window and thinking about life and late night walks on a boulevard. In this playlist you will find ballads of longing, sing-along anthems, powerful chords and melodic piano notes… Most importantly you will find the songs that you identify with personally and universally."
  },
  {
    "objectID": "mp03.html#the-ultimate-playlist-echoes-of-the-boulevard",
    "href": "mp03.html#the-ultimate-playlist-echoes-of-the-boulevard",
    "title": "Mini Project 3",
    "section": "",
    "text": "The Ulitmate Playlist is Echoes of the Boulevard. It’s a playlist that is a collection of 12 songs that expresses the emotional journey of a person going thorugh the motions of life as waves of ups and down. It bridges the nostalic notes of Coldplay with the rebellious attitudes of Green Day. It’s your go to playlist for when you are staring out the window and thinking about life and late night walks on a boulevard. In this playlist you will find ballads of longing, sing-along anthems, powerful chords and melodic piano notes… Most importantly you will find the songs that you identify with personally and universally."
  },
  {
    "objectID": "mp03.html#data-import-and-cleaning",
    "href": "mp03.html#data-import-and-cleaning",
    "title": "Mini Project 3",
    "section": "",
    "text": "For this project, we will examine the key factors that influence a song’s popularity in playlists. Our analysis will utilize the Spotify Million Playlist Dataset, a comprehensive collection of playlists and their associated tracks. Additionally, we will integrate a dataset containing Spotify songs and their audio features to enhance our insights. The table below presents the results of the data import and cleaning process, laying the groundwork for a thorough exploration of song popularity dynamics.\n\n\n\n\nCode\nensure_package &lt;- function(pkg) {\n  if (!requireNamespace(pkg, quietly = TRUE)) {\n    install.packages(pkg)\n  }\n  library(pkg, character.only = TRUE)\n}\n\n# Ensure the necessary packages are installed and loaded\nensure_package(\"dplyr\")\nensure_package(\"stringr\")\nensure_package(\"tidyr\")\nensure_package(\"httr2\")\nensure_package(\"rvest\")\nensure_package(\"datasets\")\nensure_package(\"purrr\")\nensure_package(\"DT\")\nensure_package(\"jsonlite\")\nensure_package(\"httr\")\nensure_package(\"knitr\")\n\n#Here we will load the song data from a CSV file (posted by Github User gabminamendez) \nload_songs &lt;- function() {\n  # Define file and directory paths\n  directory &lt;- \"data/mp03\"\n  file_url &lt;- \"https://raw.githubusercontent.com/gabminamedez/spotify-data/refs/heads/master/data.csv\"\n  file_path &lt;- file.path(directory, \"data.csv\")\n  \n  # Create the directory if it doesn't exist\n  if (!dir.exists(directory)) {\n    dir.create(directory, recursive = TRUE)\n  }\n  \n  # Download the file if it doesn't already exist\n  if (!file.exists(file_path)) {\n    download.file(file_url, file_path)\n    message(\"File downloaded: \", file_path)\n  } else {\n    message(\"File already exists: \", file_path)\n  }\n  \n  # Read the CSV file into a data frame\n  song_data &lt;- read.csv(file_path, stringsAsFactors = FALSE)\n  \n  # Process the artists column\n  clean_artist_string &lt;- function(x){\n    str_replace_all(x, \"\\\\['\", \"\") |&gt; \n      str_replace_all(\"'\\\\]\", \"\") |&gt;\n      str_replace_all(\" '\", \"\")\n  }\n  \n  # Process and return the data\n  processed_data &lt;- song_data |&gt; \n    separate_longer_delim(artists, \",\") |&gt;\n    mutate(artist = clean_artist_string(artists)) |&gt;\n    select(-artists)\n  \n  return(processed_data)\n}\n\n# Now actually call the function and save the result\nsong_data &lt;- load_songs()\n\n# View the first few rows to confirm it worked\n# head(song_data)\n# names(song_data)\n# \n# Next, we will load the playlist data from a JSON file (posted by Github User DevinOgrady)\n# Define the function to load the playlist data from the repository, store them locally, and return a tidy data frame to read them into R in a standardized format.\n\nload_playlist &lt;- function() {\n  p_directory &lt;- \"data/mp03/playlists\"\n  p_url &lt;- \"https://raw.githubusercontent.com/DevinOgrady/spotify_million_playlist_dataset/master/data1/\"\n  j_file_name &lt;- \"mpd.slice.0-999.json\"\n  file_path_1 &lt;- file.path(p_directory, j_file_name)\n  file_url_1 &lt;- paste0(p_url, j_file_name)\n  \n  if (!dir.exists(p_directory)) {\n    dir.create(p_directory, recursive = TRUE)\n  }\n  \n  if (!file.exists(file_path_1)) {\n    download.file(file_url_1, destfile = file_path_1, method = \"auto\")\n  }\n  \n  playlist_data &lt;- fromJSON(file_path_1, simplifyVector = FALSE)  \n  \n  if (!\"playlists\" %in% names(playlist_data)) return(NULL)\n  \n  playlist_tracks &lt;- map_dfr(playlist_data$playlists, function(pl) {\n    if (!is.list(pl)) return(NULL)\n    if (!(\"tracks\" %in% names(pl))) return(NULL)\n    if (!is.list(pl$tracks) || length(pl$tracks) == 0) return(NULL)\n    \n    tidy_data &lt;- tryCatch(\n      bind_rows(pl$tracks),\n      error = function(e) NULL\n    )\n    \n    if (is.null(tidy_data) || nrow(tidy_data) == 0) return(NULL)\n    \n    tidy_data |&gt;\n      mutate(\n        playlist_name      = pl$name,\n        playlist_id        = pl$pid,\n        playlist_followers = pl$num_followers,\n        playlist_position  = row_number()\n      ) |&gt;\n      select(\n        playlist_name,\n        playlist_id,\n        playlist_followers,\n        playlist_position,\n        track_name,\n        track_uri,\n        artist_name,\n        artist_uri,\n        album_name,\n        album_uri,\n        duration_ms\n      ) |&gt;\n      rename(\n        track_id  = track_uri,\n        artist_id = artist_uri,\n        album_id  = album_uri,\n        duration  = duration_ms\n      )\n  })\n  \n  return(playlist_tracks)\n}\n\n# Load playlists data\nplaylists_data &lt;- load_playlist()\n# glimpse(playlists_data)\n# head(playlists_data)\n# View(playlists_data)\n\n#‘Rectangle’ the Playlist Data\n#Convert the playlist data into the rectangle format, which is a tidy data frame with one row per track in a playlist.\nstrip_spotify_prefix &lt;- function(x){\n  library(stringr)\n  str_extract(x, \".*:.*:(.*)\", group=1)\n}\n\nplaylists_data &lt;- playlists_data |&gt;\n  mutate(\n    track_id  = sapply(track_id, strip_spotify_prefix),\n    artist_id = sapply(artist_id, strip_spotify_prefix),\n    album_id  = sapply(album_id, strip_spotify_prefix)\n  )\n# View(playlists_data)\n\n#create a kabble of the first 10 rows of the playlist data\nkable(playlists_data[1:10,])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplaylist_name\nplaylist_id\nplaylist_followers\nplaylist_position\ntrack_name\ntrack_id\nartist_name\nartist_id\nalbum_name\nalbum_id\nduration\n\n\n\n\nThrowbacks\n0\n1\n1\nLose Control (feat. Ciara & Fat Man Scoop)\n0UaMYEvWZi0ZqiDOoHU3YI\nMissy Elliott\n2wIVse2owClT7go1WT98tk\nThe Cookbook\n6vV5UrXcfyQD1wu4Qo2I9K\n226863\n\n\nThrowbacks\n0\n1\n2\nToxic\n6I9VzXrHxO9rA9A5euc8Ak\nBritney Spears\n26dSoYclwsYLMAKD3tpOr4\nIn The Zone\n0z7pVBGOD7HCIB7S8eLkLI\n198800\n\n\nThrowbacks\n0\n1\n3\nCrazy In Love\n0WqIKmW4BTrj3eJFmnCKMv\nBeyoncé\n6vWDO969PvNqNYHIOW5v0m\nDangerously In Love (Alben für die Ewigkeit)\n25hVFAxTlDvXbx2X2QkUkE\n235933\n\n\nThrowbacks\n0\n1\n4\nRock Your Body\n1AWQoqb9bSvzTjaLralEkT\nJustin Timberlake\n31TPClRtHm23RisEBtV3X7\nJustified\n6QPkyl04rXwTGlGlcYaRoW\n267266\n\n\nThrowbacks\n0\n1\n5\nIt Wasn’t Me\n1lzr43nnXAijIGYnCT8M8H\nShaggy\n5EvFsr3kj42KNv97ZEnqij\nHot Shot\n6NmFmPX56pcLBOFMhIiKvF\n227600\n\n\nThrowbacks\n0\n1\n6\nYeah!\n0XUfyU2QviPAs6bxSpXYG4\nUsher\n23zg3TcAtWQy7J6upgbUnj\nConfessions\n0vO0b1AvY49CPQyVisJLj0\n250373\n\n\nThrowbacks\n0\n1\n7\nMy Boo\n68vgtRHr7iZHpzGpon6Jlo\nUsher\n23zg3TcAtWQy7J6upgbUnj\nConfessions\n1RM6MGv6bcl6NrAG8PGoZk\n223440\n\n\nThrowbacks\n0\n1\n8\nButtons\n3BxWKCI06eQ5Od8TY2JBeA\nThe Pussycat Dolls\n6wPhSqRtPu1UhRCDX5yaDJ\nPCD\n5x8e8UcCeOgrOzSnDGuPye\n225560\n\n\nThrowbacks\n0\n1\n9\nSay My Name\n7H6ev70Weq6DdpZyyTmUXk\nDestiny’s Child\n1Y8cdNmUJH7yBTd9yOvr5i\nThe Writing’s On The Wall\n283NWqNsCA9GwVHrJk59CG\n271333\n\n\nThrowbacks\n0\n1\n10\nHey Ya! - Radio Mix / Club Mix\n2PpruBYCo4H7WOBJ7Q2EwM\nOutKast\n1G9G7WwrXka3Z1r7aIDjI7\nSpeakerboxxx/The Love Below\n1UsmQ3bpJTyK6ygoOOjG1r\n235213"
  },
  {
    "objectID": "mp03.html#initial-exploration",
    "href": "mp03.html#initial-exploration",
    "title": "Mini Project 3",
    "section": "",
    "text": "With a imported and cleaned dataset, we can now begin to explore the data.\n\n\nHow many distinct tracks and artists are represented in the playlist data?\n\nThere are 9,745 distinct artists and 34,443 distinct tracks in the playlist data.The following table shows the distinct artists in the playlist.\n\n\nCode\nlibrary(dplyr)\nlibrary(knitr)\nlibrary(kableExtra)\n#Count the number of distinct artists and tracks\ndistinct_artists &lt;- playlists_data |&gt;\n  distinct(artist_id) |&gt;\n  summarise(\"Number of Artists\" = n())\n#print(distinct_artists)\n\n#create a kable of distinct artists\nkable(distinct_artists)\n\n\n\n\n\nNumber of Artists\n\n\n\n\n9754\n\n\n\n\n\n The following table shows the distinct tracks in the playlist data set.\n\n\nCode\n#Count the number of distinct tracks\ndistinct_tracks &lt;- playlists_data |&gt;\n  distinct(track_id) |&gt;\n  summarise(\"Number of Tracks\" = n())\n#print(distinct_tracks)\n\n#create a kable of distinct tracks\nkable(distinct_tracks)\n\n\n\n\n\nNumber of Tracks\n\n\n\n\n34443\n\n\n\n\n\n\n\nWhat are the 5 most popular tracks in the playlist data?\nThe most popular track is Closer which made 75 appearances in the playlist data.\n\n The following table shows the 5 most popular tracks in the playlist data.\n\n\nCode\n# Find the most popular tracks\nmost_popular_tracks &lt;- playlists_data |&gt;\n  group_by(track_name) |&gt;\n  summarise(`Number of Appearances` = n()) |&gt;\n  arrange(desc(`Number of Appearances`)) |&gt;\n  slice(1:5) |&gt;\n  rename(\"Name of Track\" = track_name) \n#print(most_popular_tracks)\n#View(most_popular_tracks)\n\n# Create a kable of the most popular tracks\nkable(most_popular_tracks)\n\n\n\n\n\nName of Track\nNumber of Appearances\n\n\n\n\nCloser\n75\n\n\nOne Dance\n55\n\n\nHUMBLE.\n52\n\n\nRide\n52\n\n\nBroccoli (feat. Lil Yachty)\n50\n\n\n\n\n\n\n\nWhat is the most popular track in the playlist data that does not have a corresponding entry in the song characteristics data?\nThe most popular track that does not have a corresponding entry in the song characteristics data is One Dance by Drake. It appears 55 times in the playlist data and is shockingly not in the song characteristics data set for it’s danceability.\n\n\n\n\nCode\n#join data frames by track id column\nsong_data &lt;- song_data |&gt;\n  rename(\"track_id\" = id)\n\n#Find the most popular track that has no entry in song  data\nno_match_tracks &lt;- playlists_data |&gt;\n  anti_join(song_data, by = \"track_id\") \n\nmost_pop_nochar &lt;- (\n  no_match_tracks |&gt;\n    count(`Name of Track`= track_name, `Artist` = artist_name, sort = TRUE) |&gt;\n    slice_max(n, n = 1) |&gt;\n    rename(`Number of Appearances` = n)\n)\n\n#View(most_pop_nochar)\n\n# Create a kable of the most popular track without characteristics\nkable(most_pop_nochar)\n\n\n\n\n\nName of Track\nArtist\nNumber of Appearances\n\n\n\n\nOne Dance\nDrake\n55\n\n\n\n\n\n 4. According to the song characteristics data, what is the most “danceable” track? How often does it appear in a playlist?\nThe most danceable track is Tone-Loc's Funky Cold Medina. It appears one time in the playlist titled ***VACATION*** and has a danceability score that is closest to 1.\n\n\nCode\n# use left join to combine the song data with the playlist data\njoin_data &lt;- song_data |&gt;\n  left_join(playlists_data, by = \"track_id\")\n\n# Find the most danceable track\nmost_danceable_track &lt;- join_data |&gt;\n  select(track_name, artist_name, danceability, playlist_name) |&gt;\n  arrange(desc(danceability)) |&gt;\n  rename(\"Name of Track\" = track_name, \"Artist\" = artist_name, \"Danceability\" = danceability, \"Playlist Name\" = playlist_name) |&gt;\n  slice(1)\n\n#View(most_danceable_track)\n\n# Create a kable table to display the most danceable track\nkable(most_danceable_track)\n\n\n\n\n\nName of Track\nArtist\nDanceability\nPlaylist Name\n\n\n\n\nFunky Cold Medina\nTone-Loc\n0.988\nVACATION\n\n\n\n\n\n\n\nWhich playlist has the longest average track length?\nThe playlist with the longest average track length is the Classical playlist. It’s average track length is approximately 411148.7 milliseconds or 7 minutes.\n\n\n\nCode\n# Find the playlist with the longest average track length by grouping by playlist name \n# and calculating the average track length (average of the duration column).\n# Then, calculate the average length in minutes and sort the data frame in descending order.\n#names(playlists_data)\nlongest_playlist &lt;- playlists_data |&gt;\n  group_by(playlist_name) |&gt;\n  summarise(avg_length = mean(duration)) |&gt;\n  mutate(avg_length_min = round(avg_length/60000, 0)) |&gt;\n  arrange(desc(avg_length)) |&gt;\n  rename(\"Playlist Name\" = playlist_name, \"Average Track Length (ms)\" = avg_length, \"Average Track Length (min)\" = avg_length_min) |&gt;\n  slice(1)\n#View(longest_playlist)\n\n# Create a kable Extra table to display the playlist with the longest average track length\nkable(longest_playlist)\n\n\n\n\n\nPlaylist Name\nAverage Track Length (ms)\nAverage Track Length (min)\n\n\n\n\nclassical\n411148.7\n7\n\n\n\n\n\n\n\nWhat is the most popular playlist on Spotify?\nThe most popular playlist on Spotify is Tangled with 1038 followers.\n\n\n\nCode\n#Find the most popular playlist by grouping by playlist id and name and number of followers\nmost_popular_playlist &lt;- playlists_data |&gt;\n  distinct(playlist_id, playlist_name, playlist_followers) |&gt;\n  slice_max(playlist_followers) |&gt;\n  rename(\"Playlist ID\" = playlist_id,\"Playlist Name\" = playlist_name, \"Number of Followers\" = playlist_followers) \n#View(most_popular_playlist)\n\n# Create a kable table to display the most popular playlist\n\nkable(most_popular_playlist)\n\n\n\n\n\nPlaylist ID\nPlaylist Name\nNumber of Followers\n\n\n\n\n765\nTangled\n1038"
  },
  {
    "objectID": "mp03.html#identifying-the-ultimate-playlist",
    "href": "mp03.html#identifying-the-ultimate-playlist",
    "title": "Mini Project 3",
    "section": "",
    "text": "Next, we will conduct a more in-depth analysis of the most popular songs in the data set using INNER_JOIN to combine the song data with the playlist data set. We will use ggplot2 to visualize the data.\n\n\nIs the popularity column correlated with the number of playlist appearances? If so, to what degree?\nThe following plot shows the correlation between the popularity and the number of playlist appearances. The correlation is positive, indicating that as the popularity increases, the number of playlist appearances also increases. The thresholds are set at 0-25 for Low and 25-75 for Medium and 75-100 for High for mean popularity.\n\n\n\n\nCode\n#use inner join to combine the song data with the playlist data\ninner_join_data &lt;- song_data |&gt;\n  inner_join(playlists_data, by = \"track_id\")\n\n#using the inner join data find the correlation between the popularity and the number of playlist appearances\npop_correlation &lt;- inner_join_data |&gt;\n  group_by(track_id, track_name) |&gt;\n  summarise(num_of_playlists = n(),\n            mean_popularity = mean(popularity),\n            .groups = \"drop\") \n\n#create a new column to categorize the popularity into groups (Low, Medium, High)\n\npop_correlation &lt;- pop_correlation |&gt;\n  mutate(popularity_group = cut(\n    mean_popularity,\n    breaks = c(0, 25, 75, 100),\n    labels = c(\"Low\", \"Medium\", \"High\"),\n    include.lowest = TRUE\n  ))\n#View(pop_correlation)\n\n# Create a boxplot to display the popularity groups and their average playlist appearances\nlibrary(ggplot2)\nggplot(pop_correlation, aes(x = popularity_group, y = num_of_playlists)) +\n  geom_jitter(width = 0.2, alpha = 0.4, color = \"blue\") +\n  labs(\n    title = \"Playlist Appearances by Popularity Group\",\n    x = \"Popularity Group\",\n    y = \"Number of Playlist Appearances\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\nIn what year were the most popular songs released?.\nThe most popular songs were released in 2017. The highest average popularity of released songs was approximately 70.79.\n\n\n\nCode\n#Using the inner join data and mean, we will filter the data to find the most popular songs released in a distinct year.\npop_year &lt;- inner_join_data |&gt;\n  group_by(year) |&gt;\n  summarise(mean_pop_songs = mean(popularity, na.rm = TRUE)) |&gt;\n  arrange(desc(mean_pop_songs))\n\n#head(pop_year)\ntop_ten_pop_year &lt;- pop_year |&gt;\n  slice_head(n=10)\n#create kable of the most popular songs released in a distinct year\nkable(top_ten_pop_year) \n\n\n\n\n\nyear\nmean_pop_songs\n\n\n\n\n2017\n70.78972\n\n\n1976\n69.37306\n\n\n2016\n67.92846\n\n\n1983\n67.48315\n\n\n1982\n67.05217\n\n\n1980\n66.93662\n\n\n1981\n66.90955\n\n\n1979\n66.62581\n\n\n1967\n66.18493\n\n\n1973\n66.00585\n\n\n\n\n\nCode\n#View(pop_year)\n\n#visualize the average popularity of songs by year\npop_year_plot &lt;- ggplot(pop_year, aes(x = year, y = mean_pop_songs)) +\n  geom_line(color = \"blue\") +\n  geom_point(color = \"purple\") +\n  labs(title = \" Average Popularity of Released Songs by Year\",\n       x = \"Year\",\n       y = \"Average Popularity\")\nprint(pop_year_plot)\n\n\n\n\n\n\n\n\n\n\n\nIn what year did danceability peak?\nThe year with the highest average danceability is 2017. The average danceability for that year is 0.71.\n\n\n\nCode\n# Using the inner join data, we will filter the data to find the year with the highest average danceability.\ndanceability_year &lt;- inner_join_data |&gt;\n  group_by(year) |&gt;\n  summarise(mean_danceability = mean(danceability, na.rm = TRUE)) |&gt;\n  slice_max(mean_danceability, n = 1) |&gt;\n  rename(\"Average Danceability\" = mean_danceability)\n  \n#View(danceability_year)\n\n#create a kable of the year with the highest average danceability\n\nkable(danceability_year)\n\n\n\n\n\nyear\nAverage Danceability\n\n\n\n\n2017\n0.7120776\n\n\n\n\n\nCode\n#data to view all average danceability by year\ndanceability_year_all &lt;- inner_join_data |&gt;\n  group_by(year) |&gt;\n  summarise(mean_danceability = mean(danceability, na.rm = TRUE)) |&gt;\n  arrange(desc(mean_danceability)) \n\n#visualize the average danceability of songs by year using a line plot\ndanceability_year_plot &lt;- ggplot(danceability_year_all, aes(x = year, y = mean_danceability)) +\n  geom_line(color = \"deepskyblue\") +\n  geom_point(color = \"black\") +\n  labs(title = \"Average Danceability by Year\",\n       x = \"Year\",\n       y = \"Average Danceability\")\nprint(danceability_year_plot)\n\n\n\n\n\n\n\n\n\n\n\nWhich decade is most represented on user playlists?\nThe decade with the most songs is the 2010s. The number of 2010 songs on most users playlist at that time was 24,713.\n\n\n\nCode\n#Mutate a column to calculate the decade using integer division\npop_decade &lt;- inner_join_data |&gt;\n  mutate(decade = (year %/% 10) * 10) |&gt;\n  group_by(decade) |&gt;\n  summarise(num_songs = n()) |&gt;\n  arrange(desc(num_songs)) |&gt;\n  rename(\"Number of Songs\" = num_songs, \"Decade\" = decade)\n\n#View(pop_decade)\n# Create a kable Extra table to display the number of songs by decade\nkable(pop_decade)\n\n\n\n\n\nDecade\nNumber of Songs\n\n\n\n\n2010\n24713\n\n\n2000\n7291\n\n\n1990\n3069\n\n\n1980\n1573\n\n\n1970\n1501\n\n\n1960\n735\n\n\n1950\n93\n\n\n1940\n38\n\n\n1930\n2\n\n\n\n\n\nCode\n# Create a bar plot to visualize the number of songs by decade\npop_decade_plot &lt;- ggplot(pop_decade, aes(x = factor(`Decade`), y = `Number of Songs`)) +\n  geom_bar(stat = \"identity\", fill = \"purple\", color = \"black\") +\n  labs(title = \"Number of Songs by Decade\",\n       x = \"Decade\",\n       y = \"Number of Songs\") +\n  theme_minimal()\n\nprint(pop_decade_plot)\n\n\n\n\n\n\n\n\n\n\n\nPlotting the key frequency among songs\nThe most common key is the 0 and 1 keys. The frequency of those key is more than 1,000.\n\n\n\nCode\n# Calculate the frequency of each key\nkey_frequency &lt;- inner_join_data |&gt;\n  group_by(key) |&gt;\n  summarize(count = n()) |&gt;\n  arrange(desc(count))\n\n# Create a polar plot...\nggplot(key_frequency, aes(x = as.factor(key), y = count)) +\n  geom_bar(stat = \"identity\", fill = \"darkgreen\", color = \"black\") +\n  coord_polar(start = 0) +\n  theme_bw() +\n  labs(title = \"Frequency of Musical Keys\",\n       x = \"Key\",\n       y = \"Count of Keys\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1),\n        axis.text = element_text(size = 12),\n        axis.title = element_text(size = 14),\n        plot.title = element_text(size = 16))\n\n\n\n\n\n\n\n\n\n\n\nWhat are the most popular track lengths?\nThe following histogram shows the distribution of track lengths. The most common track length is between 2 and 4 minutes.\n\n\n\nCode\n#using the inner join data, we will filter the data to find the most popular track lengths (in minutes)\ninner_join_data&lt;- inner_join_data |&gt;\n  mutate(track_length = duration/ 60000)\n\n#find the mean, median, min, and max track lengths\ntrack_length_data &lt;- inner_join_data |&gt;\n  summarise(\n    avg_length = mean(track_length, na.rm = TRUE),\n    median_length = median(track_length, na.rm = TRUE),\n    min_length = min(track_length, na.rm = TRUE),\n    max_length = max(track_length, na.rm = TRUE)\n  ) \n#View(track_length_data)\n#Create a kable table to display the track length data\nkable(track_length_data)\n\n\n\n\n\navg_length\nmedian_length\nmin_length\nmax_length\n\n\n\n\n3.974142\n3.833333\n0.0034333\n37.31222\n\n\n\n\n\nCode\n#Create a histogram to visualize the distribution of track lengths\nggplot(inner_join_data, aes(x = track_length)) +\n  geom_histogram(binwidth = 0.6, fill = \"cornflowerblue\", color = \"black\") +\n  labs(title = \"Most Popular Track Lengths\",\n       x = \"Track Length (minutes)\",\n       y = \"Number of Songs\") +\n  theme_bw() +\n  scale_x_continuous(\n    limits = c(0, 10),       # Only min and max go here\n    breaks = seq(0, 10, 2)   # Add ticks every 2 minutes\n  )"
  },
  {
    "objectID": "mp03.html#building-a-playlist-from-anchor-songs",
    "href": "mp03.html#building-a-playlist-from-anchor-songs",
    "title": "Mini Project 3",
    "section": "",
    "text": "Now that exploring the data is finished we can build the playlist! First, we picked two anchor songs from the playlist data set: Wake Me Up When September Ends by Green Day and Fix You by Coldplay. Then, we found songs that work well in the playlist using heuristics.\n\n\n\n\n\nWhat other songs commonly appear on playlists along side this song?\n\n\n\nCode\n#Using inner join data we will filter the data to find the anchor songs and their characteristics. \nanchor_songs &lt;- inner_join_data |&gt;\n  filter(track_name %in% c(\"Wake Me Up When September Ends\", \"Fix You\")) |&gt; \n  distinct(track_id, track_name, artist_name, key, tempo, year, popularity, acousticness, danceability, valence, instrumentalness,energy)\n#View(anchor_songs)\n\n#distinct(inner_join_data, track_name) |&gt; View()\n\n#Heuristic 1: Songs that Commonly Appear with the Anchor Song\n#We'll find songs that appeared in the same playlists as the anchor song(s).\n\nanchor_ids &lt;- anchor_songs$track_id\n\nco_occurring_tracks &lt;- playlists_data |&gt;\n  filter(track_id %in% anchor_ids) |&gt;\n  select(playlist_id) |&gt;\n  inner_join(playlists_data, by = \"playlist_id\") |&gt;\n  filter(!track_id %in% anchor_ids) |&gt;  # exclude the anchor itself\n  count(track_name, artist_name, sort = TRUE) |&gt;\n  slice_max(n, n = 20)\n# Rename columns for clarity\n\nco_occurring_tracks &lt;- co_occurring_tracks |&gt;\n  rename(\n    `Track Name` = track_name,\n    `Artist Name` = artist_name,\n    `Number of Playlists` = n\n  )\n\n#View(co_occurring_tracks)\ntop_ten_co_ocurring &lt;- co_occurring_tracks |&gt;\n  slice_head(n = 10)\n# Create a kable table to display the similar co-occuring tracks\nkable(top_ten_co_ocurring) \n\n\n\n\n\n\n\n\n\n\nTrack Name\nArtist Name\nNumber of Playlists\n\n\n\n\nChasing Cars\nSnow Patrol\n9\n\n\nDrops of Jupiter\nTrain\n8\n\n\nI Write Sins Not Tragedies\nPanic! At The Disco\n7\n\n\nYellow\nColdplay\n7\n\n\n21 Guns\nGreen Day\n6\n\n\nMr. Brightside\nThe Killers\n6\n\n\nShe Will Be Loved - Radio Mix\nMaroon 5\n6\n\n\nThe Scientist\nColdplay\n6\n\n\nHoliday/Boulevard Of Broken Dreams\nGreen Day\n5\n\n\nHow to Save a Life\nThe Fray\n5\n\n\n\n\n\n\n\nWhat other songs are in the same key and have a similar tempo?\n\nThe following table shows the songs that are in the same key and have a similar tempo to the anchor songs. The tempo is between 5 BPM of the anchor songs.\n\n\nCode\n################\n#Heuristic 2: Same Key + Similar Tempo (±5 BPM)\nlibrary(purrr)\nsimilar_key_tempo &lt;- inner_join_data |&gt;\n  filter(\n    key %in% anchor_songs$key,\n    map_lgl(tempo, ~ any(abs(.x - anchor_songs$tempo) &lt;= 5))\n  ) |&gt;\n  distinct(track_id, track_name, artist_name, tempo, key)|&gt;\n  slice_max(tempo, n = 15) # Get top 10 similar tracks\n\n# Rename columns for clarity\nsimilar_key_tempo &lt;- similar_key_tempo |&gt;\n  rename(\n    `Track Name` = track_name,\n    `Artist Name` = artist_name,\n    `Tempo (BPM)` = tempo,\n    `Key` = key\n  )\n\n#View(similar_key_tempo)\ntop_ten_keytemp &lt;- similar_key_tempo  |&gt;\n  slice_head(n = 10)\n# Create a kable table to display the similar key tempo tracks\nkable(top_ten_keytemp) \n\n\n\n\n\n\n\n\n\n\n\n\ntrack_id\nTrack Name\nArtist Name\nTempo (BPM)\nKey\n\n\n\n\n71tjsDvB4EMJqNG8EMmFnb\nComin’ Home Baby\nMel Tormé\n143.121\n7\n\n\n1f2lkuLldqRzvaFjJdjGXX\nSanta Claus Is Comin’ to Town\nMariah Carey\n143.109\n7\n\n\n4NTWZqvfQTlOMitlVn6tew\nThe Show Goes On\nLupe Fiasco\n143.067\n7\n\n\n10eDxSTjwMBq1ZjZK5b1cK\nMillennia\nCrown The Empire\n143.036\n3\n\n\n2rUwQj4SWaP2anuGDtNpYR\nSelf-Made\nBryson Tiller\n143.001\n7\n\n\n0UDCfleTgwihlnOUxbzokR\nAwake\nBTS\n142.816\n3\n\n\n6NGi23FFKq9tH5NR1NcTw2\nLet Her Cry\nHootie & The Blowfish\n142.570\n7\n\n\n3403qFGo7u2ptUyJbdEkjI\nFor the Widows in Paradise, For the Fatherless in Ypsilanti\nSufjan Stevens\n142.433\n3\n\n\n4F55RCGuM477OjznpYGhYz\nShortie Like Mine\nBow Wow\n142.149\n7\n\n\n7g8OpS827dAYU067lZaR0L\nJust a Dream\nCarrie Underwood\n142.060\n7\n\n\n\n\n\n\n\nWhat other songs were released by the same artists?\n\n\n\nCode\n#Heuristic 3: Same Artist\nsame_artist_tracks &lt;- inner_join_data |&gt;\n  filter(artist_name %in% anchor_songs$artist_name) |&gt;\n  distinct(track_id, track_name, artist_name)\n\n#View(same_artist_tracks)\n# Create a kable Extra table to display the same artist tracks\n\ntop_ten_same &lt;- same_artist_tracks |&gt;\n  slice_head(n = 10)\n\nkable(top_ten_same) \n\n\n\n\n\ntrack_id\ntrack_name\nartist_name\n\n\n\n\n31L9yLXSj6LpCFupyMV6CR\nUp&Up\nColdplay\n\n\n5qfZRNjt2TkHEL12r3sDEU\nEverglow\nColdplay\n\n\n4ZcnZVXwLDLWI93SLJER3a\nMisery\nGreen Day\n\n\n1rkbMXhEjIytsUGbhoR5pn\nLife In Technicolor\nColdplay\n\n\n1qIgyDoc2rwtq8w49jeWL8\nOh Love\nGreen Day\n\n\n6f49kbOuQSOsStBpyGvQfA\nA Head Full Of Dreams\nColdplay\n\n\n6FnDerFHdaeCFovZnQ3r14\nLast Ride In\nGreen Day\n\n\n3KzCJGegAcwsSik1bOgkNu\nWords I Might Have Ate\nGreen Day\n\n\n6c6W25YoDGjTq3qSPOga5t\nInk\nColdplay\n\n\n3HWDWyIqWuLsTHECx9DvXF\nBirds\nColdplay\n\n\n\n\n\n\n\nWhat other songs were released in the same year and have similar levels of acousticness and danceability?\n\nWe’ll allow a range (±0.1) around the acousticness/danceability of the anchor songs.\n\n\nCode\n# heuristic 4 - \n# We'll allow a range (±0.1) around the acousticness/danceability of the anchor songs.\n#find the range of years for the anchor songs\n#and filter the data to find the similar songs\n\n\nanchor_range &lt;- anchor_songs |&gt;\n  summarise(\n    min_acoustic = min(acousticness) - 0.1,\n    max_acoustic = max(acousticness) + 0.1,\n    min_dance = min(danceability) - 0.1,\n    max_dance = max(danceability) + 0.1,\n    year_range = list(unique(year))  # make year_range a list-column\n  )\n\n# Pull the scalar values from the 1-row data frame\nmin_acoustic &lt;- anchor_range$min_acoustic\nmax_acoustic &lt;- anchor_range$max_acoustic\nmin_dance &lt;- anchor_range$min_dance\nmax_dance &lt;- anchor_range$max_dance\nyear_range &lt;- anchor_range$year_range[[1]]  # unlist the year_range safely\n\n# Now filter safely\nsimilar_vibe_tracks &lt;- inner_join_data |&gt;\n  filter(\n    year %in% year_range,\n    acousticness &gt;= min_acoustic,\n    acousticness &lt;= max_acoustic,\n    danceability &gt;= min_dance,\n    danceability &lt;= max_dance\n  ) |&gt;\n  distinct(track_id, track_name, artist_name, year)\n\n\n#View(similar_vibe_tracks)\ntop_ten_vibe &lt;- similar_vibe_tracks |&gt;\n  slice_head(n = 10)\n\n#create a kable table to display the similar vibe tracks\nkable(top_ten_vibe)\n\n\n\n\n\n\n\n\n\n\n\ntrack_id\ntrack_name\nartist_name\nyear\n\n\n\n\n28jOIJzouTp7gqhtx7RbGa\nBlame It On Bad Luck\nBayside\n2005\n\n\n4e4vO6bp5nSdP9G79O3qS6\nMiss Me Baby\nChris Cagle\n2005\n\n\n2YxoC2dYOotjqt08dEifsc\nChromakey Dreamcoat\nBoards of Canada\n2005\n\n\n2itu79WbZhUCHX4jg0fyAd\nNever Let This Go\nParamore\n2005\n\n\n53Qpn8LPa0IhFCTiPO0Bbm\nI Disappear\nThe Faint\n2004\n\n\n0L639McB94IkUvIgZKM1E5\nPirates\nBullets And Octane\n2004\n\n\n5fHkJ1a7v0JFPiT9rFQI8U\nTe Daré Lo Mejor\nJesús Adrián Romero\n2004\n\n\n6u84UiQ3TRczfYTDVYrz7S\nSomeone That You’re With\nNickelback\n2005\n\n\n433JymbpWnRMHXzp1oTRP7\nDon’t Bother\nShakira\n2005\n\n\n4sjjV02cN3nDOIZPJabEgM\nThe Time Is Now\nJohn Cena\n2005\n\n\n\n\n\n\n\nWhat other songs were released have similar levels of valence?\n\n\n\nCode\n#Valence(Mood) or emotional tone of the track\n# names(anchor_songs)\n#We will use the valence column to find similar songs\nvalence_range &lt;- anchor_songs |&gt; summarise(\n  min_valence = min(valence) - 0.001,\n  max_valence = max(valence) + 0.001\n)\n#compare  the valence of the anchor songs to the valence of the other songs\nsimilar_valence_tracks &lt;- inner_join_data |&gt;\n  filter(\n    valence &gt;= valence_range$min_valence,\n    valence &lt;= valence_range$max_valence\n  ) |&gt;\n  distinct(track_id, track_name, artist_name, valence)\n\n# Rename columns for clarity\nsimilar_valence_tracks &lt;- similar_valence_tracks |&gt;\n  rename(\n    `Track Name` = track_name,\n    `Artist Name` = artist_name,\n    `Valence` = valence\n  )\n\n#View(similar_valence_tracks)\ntop_ten_valence &lt;- similar_valence_tracks |&gt;\n  slice_head(n = 10)\n# Create a kable table to display the similar valence tracks\nkable(top_ten_valence) \n\n\n\n\n\n\n\n\n\n\n\ntrack_id\nTrack Name\nArtist Name\nValence\n\n\n\n\n3lpa6fzS3rSAbRogEhWxu7\nStar Spangled Banner - Live at Woodstock\nJimi Hendrix\n0.129\n\n\n1YBf7Tq9bpcVwvnlP8YbQS\nYear Zero\nGhost B.C.\n0.137\n\n\n52WTLETEHs5jwCr7LCq0VW\nQueen\nPerfume Genius\n0.130\n\n\n5qfZRNjt2TkHEL12r3sDEU\nEverglow\nColdplay\n0.136\n\n\n0WCbhE2evMrIwRM0DlMy9k\nMixtape (feat. Young Thug & Lil Yachty)\nChance The Rapper\n0.126\n\n\n5eG8QuQKOBvDeCyoOeMkhT\nAlps\nNovo Amor\n0.135\n\n\n7hmdJhc4W0idVVoMES7F9F\nIf I Know Me\nGeorge Strait\n0.146\n\n\n4qKDjmz094Bu2wMepNuwVN\nMain Title / Once Upon A Dream / Prologue - From “Sleeping Beauty” Soundtrack\nChorus - Sleeping Beauty\n0.143\n\n\n1fckqKAI9ug7U1DgQrrOop\nBelieve It - feat. Rick Ross\nMeek Mill\n0.138\n\n\n0st2C7aLz9xkr7JyshhUHK\nScandal of Grace\nHillsong United\n0.138"
  },
  {
    "objectID": "mp03.html#creating-the-ultimate-playlist-1",
    "href": "mp03.html#creating-the-ultimate-playlist-1",
    "title": "Mini Project 3",
    "section": "",
    "text": "The following playlist is comprised of the offical 12 candidates selected for the playlist before ordering. It was created using all four heurtics above to find songs of similar standing as the chosen anchor songs. Additionally, it’s comprised of 2 songs that I was not familiar with, I Disappear and Chromakey Dreamcoat. This means that the playlist is also pretty diverse in terms of popularity.\n\n\n\nCode\n#final Playlist Candidate\n#Now combine all those results and filter down to at least 20 unique songs, making sure at least 8 are not “popular” (say, popularity &lt; 60)\nanchor_artists &lt;- unique(anchor_songs$artist_name)\nanchor_ids &lt;- unique(anchor_songs$track_id)\nall_candidates &lt;- bind_rows(\n  co_occurring_tracks,\n  similar_key_tempo,\n  similar_vibe_tracks,\n  similar_valence_tracks\n) |&gt;\n  filter(!artist_name %in% anchor_artists) |&gt;\n  distinct(track_id, track_name, artist_name)\n\n# Join with popularity info\nfinal_candidates &lt;- all_candidates |&gt;\n  inner_join(inner_join_data |&gt; select(track_name, artist_name, popularity,valence,energy,danceability), by = c(\"track_name\", \"artist_name\")) |&gt;\n  distinct() |&gt;\n  mutate(\n    is_popular = ifelse(popularity &gt;= 60, \"Not Popular\", \"Popular\"))\npopular_split &lt;- final_candidates |&gt;\n  group_split(is_popular)\n\nnon_popular &lt;- popular_split[[which(levels(as.factor(final_candidates$is_popular)) == \"Not Popular\")]] |&gt;\n  slice_head(n = 4)\n\npopular &lt;- popular_split[[which(levels(as.factor(final_candidates$is_popular)) == \"Popular\")]] |&gt;\n  slice_head(n = 6)\n\nfinal_playlist &lt;- bind_rows(non_popular, popular)\n\n# Select relevant columns from anchor_songs\nanchor_clean &lt;- anchor_songs |&gt;\n  select(track_id, track_name, artist_name, popularity, valence, energy, danceability)\n\n# Combine with the rest of the playlist\nfinal_playlist &lt;- bind_rows(final_playlist, anchor_clean) |&gt;\n  distinct(track_id, .keep_all = TRUE) # Avoid duplicates\n\nkable(final_playlist)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrack_id\ntrack_name\nartist_name\npopularity\nvalence\nenergy\ndanceability\nis_popular\n\n\n\n\n2JdhRRTl3ee6pQQupVQqyb\nHow Great Is Our God\nChris Tomlin\n63\n0.0765\n0.573\n0.318\nNot Popular\n\n\n7oK9VyNzrYvRFo7nQEYkWN\nMr. Brightside\nThe Killers\n78\n0.2320\n0.924\n0.356\nNot Popular\n\n\n5oQcOu1omDykbIPSdSQQNJ\n1985\nBowling For Soup\n70\n0.9030\n0.887\n0.606\nNot Popular\n\n\n7lRlq939cDG4SzWOF4VAnd\nI’m Not Okay (I Promise)\nMy Chemical Romance\n73\n0.2550\n0.940\n0.210\nNot Popular\n\n\n28jOIJzouTp7gqhtx7RbGa\nBlame It On Bad Luck\nBayside\n44\n0.4140\n0.692\n0.323\nPopular\n\n\n4e4vO6bp5nSdP9G79O3qS6\nMiss Me Baby\nChris Cagle\n43\n0.3570\n0.569\n0.526\nPopular\n\n\n2YxoC2dYOotjqt08dEifsc\nChromakey Dreamcoat\nBoards of Canada\n50\n0.7660\n0.825\n0.643\nPopular\n\n\n2itu79WbZhUCHX4jg0fyAd\nNever Let This Go\nParamore\n49\n0.5290\n0.880\n0.519\nPopular\n\n\n53Qpn8LPa0IhFCTiPO0Bbm\nI Disappear\nThe Faint\n45\n0.6770\n0.860\n0.627\nPopular\n\n\n0L639McB94IkUvIgZKM1E5\nPirates\nBullets And Octane\n51\n0.7580\n0.907\n0.521\nPopular\n\n\n3ZffCQKLFLUvYM59XKLbVm\nWake Me Up When September Ends\nGreen Day\n76\n0.1460\n0.814\n0.546\nNA\n\n\n7LVHVU3tWfcxj5aiPFEW4Q\nFix You\nColdplay\n81\n0.1240\n0.417\n0.209\nNA"
  }
]